'''
동빈이의 큰 수의 법칙은 다양한 수로 이루어진 배열이 있을 때, 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙이다.
단 배열의 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 이 법칙의 특징이다.
예를 들어 순서대로 2,4,5,4,6으로 이루어진 배열이 있을 때, M이 8이고 K가 3이라고 가정하자. 이 경우 특정한 인덱스의 수가
연속해서 3번까지만 더해질 수 있으므로, 큰 수의 법칙에 따른 결과는 6+6+6+5+6+6+6+5인 46이 된다.
단 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주한다.
예를 들어 3,4,3,4,3으로 이루어진 배열이 있을 때, M이 7이고 K가 2라고 가정하자. 이 경우 두 번째 원소에 해당하는 4와
4번째 원소에 해당하는 4를 번갈아 2번씩 더하는 것이 가능하다. 결과적으로 4+4+ 4+4+ 4+4 + 4+4인 28이 도출된다.
배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 동빈이의 큰 수의 법칙에 따른 결과를 출력하시오.
- 2 <= N <= 1,000
- 1 <= M <= 1,000
- 1 <= K <= 10,000
- 각 자연수는 공백으로 구분한다.
- 둘째 줄에 N개의 자연수가 주어진다.
'''

N, M, K = map(int, input().split())
arr = list(map(int, input().split()))

total_count = 0 # 지금까지 더한 횟수
index = -1 # 가장 큰 수가 위치한 인덱스 값
before_index = -1 # 이전에 찾은 가장 큰수의 인덱스 값
max_value = 0 # 이전에 찾은 가장 큰 수의 값
result = 0 # 모두 더한 값

# 0. 더한 횟수가 M번이 될때까지 반복한다.
while total_count < M:
    # 1. 가장 큰 값 찾기
    # 이전에 이미 찾은 값이라면 제외해야 한다.
    # enumerate 순서 주의! 먼저 오는게 인덱스 값, 뒤에 오는데 value이다.
    for idx, val in enumerate(arr):
        # 큰 값을 찾았다면
        if val >= max_value:
            # 해당 값이 이전에 찾은 큰 값이라면 넘어간다.
            if idx == before_index:
                continue
            else:
                max_value = val
                index = idx

    # 2. 찾았으면 해당 값을 K번만큼 더한다.
    for i in range(K):
        total_count += 1
        # 만약 더한 횟수가 M 이상이라면 중단한다.
        if total_count > M:
            break
        else:
            result += max_value
    # max값을 더했으면, max_value는 초기화한다.
    max_value = 0
    before_index = index
    index = -1

# M번 더했으면 결과를 출력한다.
print(result)


# 문제를 완전 잘못 이해함...
# 최대 K번까지 더할 수 있다라는 거지, 반드시 K번을 모두 채워야 하는 것은 아니다!
# 베스트는 최대 큰수를 K번 더하고, 그 다음 큰 수를 1번 더하고, 그 다음 최대 큰수를 K번 더하고... 를 반복!