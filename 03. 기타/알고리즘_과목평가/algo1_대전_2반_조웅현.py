# 1. 정원에 나무 심기

# 가장 먼저, 테스트 케이스의 개수 T를 입력으로 받는다. 이 때, 기본적으로 사용자에게 받는
# 입력값의 유형은 str이므로, 내장함수 int()를 통해 정수형으로 변환한다.
T = int(input())

for tc in range(1,T+1): # 테스트 케이스의 개수만큼 반복문을 수행한다.

    # 정원의 크기를 나타내는 행의 개수 N과 열의 개수 M을 받는다.
    # 이 때 list()는 데이터를 list 형태로 변환하는 역할을 하며,
    # map()의 경우 iterable한 객체에 대해 반복적으로 특정 함수를 수행하고자 할 때 사용한다.
    # 또한 split()의 경우 사용자로부터 입력받은 값을 특정 기준(str값)을 통해 나누고자 할 때 사용되며
    # 인자값을 입력하지 않은 경우 공백(' ')을 통해 분할한다.

    N,M = list(map(int,input().split()))
    # 위와 같은 표현을 통해 만약 입력값이 "1 2"라면 N에는 1을, M에는 2를 저장할 수 있다.

    # 아래의 표현은 list comprehension을 통해 리스트를 만든 것이다.
    # list에 담길 모든 값은 map() 함수를 통해 정수(int)로 변환된다.
    arr = [list(map(int,input().split())) for i in range(N)]

    max_price = 0 # 가장 비싼 나무의 가격을 저장하기 위해 필요한 변수
    max_column = 0 # 가장 비싼 나무가 위치한 열 정보를 저장하기 위한 변수
    total_price = 0 # 나무를 심는데 필요한 총 비용을 저장하기 위한 변수
    tree_cnt = 0 # 나무의 개수를 저장하기 위해 필요한 변수
    # 나무를 세로방향으로 심으므로, 열 우선 탐색으로 list에 접근한다.

    for col in range(M): # 이 때 M은 열의 개수이다.
        for row in range(N): # 이 때 N은 행의 개수이다.
            # 나무를 한칸 한칸 띄워 심는다 -> 짝수번째 열에 대해서만 고려한다. (0,2,4...)
            if col % 2 == 0: # 짝수 열에 대해서만 수행한다. 'col을 2로 나눴을 때의 나머지가 0이라면' 라는 뜻이다.
                # 짝수의 경우 2로 나눴을 때 나머지가 0이고, 홀수의 경우 2로 나눴을 때 나머지가 1이다.
                # % 연산자는 나머지 연산자이다.
                total_price += arr[row][col]  # 열방향으로 for문을 진행함에 따라, 각 나무(arr의 (row, col) 인덱스에 위치한 값)의 비용을 total_price에 저장한다.
                tree_cnt += 1 # row가 변함에 따라 , 나무를 하나씩 센다.

                 # 가장 비싼 나무는 어떤 나무인지 판단한다.
                if arr[row][col] > max_price: # 만약 정원 내 (row, col)번째 나무의 가격이 저장된 최대값(max_price)보다 크다면
                    max_price = arr[row][col] # 가장 비싼 나무를 (row, col)번째 나무의 가격으로 저장한다.
                    max_column = col + 1 # 가장 비싼 나무가 있는 열 번호를 저장한다.
                    # 이 때, +1을 하는 이유는 python에서 가장 첫번째 열 번호는 0이지만,
                    # 가장 첫번째임을 나타내려면 0이 아닌 1부터 시작해야 하기 때문에 1을 더하였다.

                # 만약 가장 비싼 나무의 비용과 동일한 가격이 비교된다면? 열 번호를 비교하여, 열번호가 큰 값을 최대값으로 저장한다.
                if arr[row][col] == max_price: # 만약 현재 나무의 가격이 저장된 가장 비싼 나무 가격과 같다면
                    # 열 번호를 기준으로 판단해야 한다.
                    if col >= max_column: # 만약 현재 열번호가 현재 최대값의 열번호보다 크다면:
                        arr[row][col] = max_price # 최대값을 변경하고
                        max_column = col + 1 # 열번호 또한 변경한다. 또한 위와 마찬가지 이유로 +1을 한다.
                    else: # 최대값이 위치한 나무의 열번호보다 크지 않은 경우:
                        pass # 최대값을 변경하지 않는다.


    # f-string을 이용하여 우리가 저장한 변수값을 str로 변환하지 않고도 바로 출력할 수 있다.
    # '{} {}'.format(a,b)와 같이도 작성할 수 있다.
    print(f'#{tc} {total_price} {tree_cnt} {max_price} {max_column}')




